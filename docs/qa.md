# Вопросы по архитектуре проекта PPTX Import

## Архитектурные вопросы

### 1. Структура проекта и сборка
**Вопрос**: Какой подход к сборке предпочтительнее для Figma плагина?
- **Вариант A**: Vite с настройкой для Figma плагинов
- **Вариант B**: ESBuild с кастомной конфигурацией
- **Вариант C**: Webpack с figma-plugin-ds

**Контекст**: Необходимо обеспечить hot reload для разработки и оптимизированную сборку для продакшена.

**✅ РЕШЕНИЕ**: Гибридный подход - Vite для UI + ESBuild для main
- **Обоснование**: Vite даёт быстрый dev-server и удобный DX для React-UI, а code.ts (main) не требует dev-сервера — там важны скорость и простота, где esbuild идеален
- **Реализация**: Настраиваем два энтрипойнта и общий tsconfig. Если нужна «автопересборка» — вотчер esbuild + авто-reload UI
- **Компромисс**: Между вариантами A и B; Webpack (C) избыточен

### 2. Управление состоянием UI
**Вопрос**: Какой подход к управлению состоянием использовать в React UI?
- **Вариант A**: useState/useReducer для простого состояния
- **Вариант B**: Zustand для более сложного состояния
- **Вариант C**: Context API с useReducer

**Контекст**: UI должен отслеживать прогресс импорта, настройки пользователя и отображать результаты.

**✅ РЕШЕНИЕ**: Zustand (B)
- **Обоснование**: Мало бойлерплейта, естественно работает с постмесседжами и прогрессом, не захламляет контекстами
- **Дополнение**: Для форм опций можно поверх подключить react-hook-form

### 3. Система сообщений UI ↔ Main
**Вопрос**: Как структурировать систему сообщений между UI и основным кодом?
- **Вариант A**: Простые строковые типы сообщений
- **Вариант B**: Типизированные сообщения с payload
- **Вариант C**: Event-driven система с подписками

**Контекст**: Необходимо передавать большие объемы данных (ArrayBuffer, прогресс, логи).

**✅ РЕШЕНИЕ**: Строго типизированные сообщения с payload (B) + мини-шина событий
- **Обоснование**: Делаем type Message = { type: 'progress'|'slide'|'warn'|..., payload: ... } (discriminated union)
- **Валидация**: На границе — валидация через zod/valibot
- **Преимущества**: Легко трассировать и расширять
- **Дополнение**: Полноценная подписочная система (C) не нужна, но внутри UI можно сделать маленький event-emitter для локального роутинга сообщений

### 4. Обработка больших файлов
**Вопрос**: Как обеспечить неблокирующую обработку больших PPTX файлов?
- **Вариант A**: Web Workers для парсинга
- **Вариант B**: Async/await с yield между слайдами
- **Вариант C**: Потоковая обработка с chunking

**Контекст**: Файлы 100+ слайдов не должны замораживать UI.

**✅ РЕШЕНИЕ**: Комбинация A + B: парсинг в Web Worker (UI-контекст), рендер в main с await/yield между слайдами
- **Обоснование**: Тяжёлый парсинг/распаковка ZIP и XML нагружают UI — переносим в воркер
- **Main процесс**: Создаёт ноды и делает await figma.loadFontAsync/await Promise.resolve() для «дыхания» между батчами
- **Передача данных**: Поштучно по слайдам (transferable ArrayBuffer → минимизировать копии)

## Технические вопросы

### 5. Кэширование и дедупликация
**Вопрос**: Как организовать кэширование ресурсов?
- **Вариант A**: In-memory кэш в ImportContext
- **Вариант B**: IndexedDB для персистентного кэша
- **Вариант C**: Гибридный подход с LRU кэшем

**Контекст**: Необходимо кэшировать шрифты, изображения, темы для производительности.

**✅ РЕШЕНИЕ**: Гибрид (C): in-memory ImportContext + LRU; без IndexedDB на MVP
- **Обоснование**: В main нет IndexedDB, а межсессионная персистентность не критична
- **Реализация**: Делаем кэш шрифтов/медиа/тем в памяти, плюс LRU для изображений
- **Дедупликация**: Дедуп изображений — по хэшу байтов
- **Дополнение**: Если позже понадобится межсессионный кэш — можно добавить IndexedDB в UI только для предпросмотров
- **Практика**: Быстрый и надёжный хэш: xxhash-wasm для Uint8Array; хранить map <hash → ImagePaint>

### 6. Обработка шрифтов
**Вопрос**: Как обрабатывать отсутствующие шрифты?
- **Вариант A**: Таблица соответствий в JSON
- **Вариант B**: Автоматическое определение похожих шрифтов
- **Вариант C**: Fallback на системные шрифты Figma

**Контекст**: PPTX может содержать шрифты, недоступные в Figma.

**✅ РЕШЕНИЕ**: JSON-таблица соответствий (A) + fallback Inter
- **Обоснование**: Предсказуемость
- **Процесс**: На старте делаем «префлайт» списка используемых шрифтов → батч-loadFontAsync
- **Fallback**: Не найдено — подставляем из таблицы, затем Inter, и пишем понятное предупреждение
- **Важно**: Не полагаться на «автовыбор похожих» (B)

### 7. Масштабирование и координаты
**Вопрос**: Как точно масштабировать элементы до 1920×1080?
- **Вариант A**: Единый коэффициент масштабирования для всего слайда
- **Вариант B**: Адаптивное масштабирование с учетом контента
- **Вариант C**: Пользовательский выбор масштабирования

**Контекст**: Необходимо сохранить пропорции и позиционирование элементов.

**✅ РЕШЕНИЕ**: Единый коэффициент (A) — Fit до 1920×1080 с полями
- **Обоснование**: Детерминированно, без «плавающих» искажений
- **Формула**: scale = min(1920/w, 1080/h), выравнивание по центру
- **Применение**: Все координаты/размеры умножаем на scale

### 8. Обработка неподдерживаемых элементов
**Вопрос**: Как обрабатывать SmartArt и диаграммы?
- **Вариант A**: Попытка векторизации через доступные данные
- **Вариант B**: Растеризация в изображение
- **Вариант C**: Плейсхолдер с предупреждением

**Контекст**: Некоторые элементы PPTX не имеют прямых аналогов в Figma.

**✅ РЕШЕНИЕ**: Порядок: A → B → C
- **Обоснование**: Сначала пробуем извлечь пригодный вектор (если есть DrawingML для частей), иначе растр из превью (часто у объектов есть thumbnail), в крайнем случае — плейсхолдер с предупреждением
- **Согласованность**: Согласуется с требованиями graceful degradation

## Вопросы производительности

### 9. Оптимизация рендеринга
**Вопрос**: Как оптимизировать создание узлов Figma?
- **Вариант A**: Батчевое создание узлов
- **Вариант B**: Ленивая загрузка элементов
- **Вариант C**: Предварительная валидация данных

**Контекст**: Создание множества узлов может быть медленным.

**✅ РЕШЕНИЕ**: A + C
- **Обоснование**: «Батчевое» создание в Figma — это, по сути, минимизация промежуточных мутаций: создаём все узлы слайда локально, затем одним проходом вставляем в фрейм и проставляем свойства/пейнты
- **Валидация**: Перед этим — предвалидация данных (C), чтобы не откатывать
- **Дополнение**: «Ленивая загрузка» (B) для импортера не столь полезна

### 10. Управление памятью
**Вопрос**: Как избежать утечек памяти при обработке больших файлов?
- **Вариант A**: Явное освобождение ресурсов
- **Вариант B**: Использование WeakMap/WeakSet
- **Вариант C**: Периодическая очистка кэша

**Контекст**: Большие изображения и данные могут занимать много памяти.

**✅ РЕШЕНИЕ**: A + B + C
- **Обоснование**: После создания ImagePaint очищаем временные буферы; для карт/шрифтов — WeakMap, чтобы GC мог собирать неиспользуемое; плюс периодическая очистка LRU, чтобы не разрастался кэш при 100+ слайдах

## Вопросы совместимости

### 11. Версионирование PPTX
**Вопрос**: Как обрабатывать разные версии PPTX формата?
- **Вариант A**: Поддержка только современных версий
- **Вариант B**: Адаптеры для разных версий
- **Вариант C**: Автоматическое определение версии

**Контекст**: PPTX формат эволюционировал, могут быть различия в структуре.

**✅ РЕШЕНИЕ**: Авто-детект (C) + «современный профиль» как основной
- **Обоснование**: OOXML стабилен, но встречаются артефакты старых генераторов
- **Реализация**: Авто-определяем особенности (rels, схемы тем, геометрии), а экзотику мягко деградируем

### 12. Совместимость с Figma API
**Вопрос**: Как обеспечить совместимость с будущими версиями Figma API?
- **Вариант A**: Использование только стабильных API
- **Вариант B**: Feature detection и fallbacks
- **Вариант C**: Версионирование плагина

**Контекст**: Figma API может изменяться, необходимо обеспечить стабильность.

**✅ РЕШЕНИЕ**: A + B
- **Обоснование**: Опираемся на стабильные части API и делаем feature-detection на спорные (например, списки)
- **Архитектура**: Поддерживаем небольшой слой-адаптер (facade), чтобы при изменениях API править один модуль
- **Дополнение**: Версионирование плагина (C) само собой, но не как главный инструмент

## Вопросы тестирования

### 13. Структура тестов
**Вопрос**: Как организовать тестирование плагина?
- **Вариант A**: Unit тесты для парсера и маппера
- **Вариант B**: Integration тесты с моком Figma API
- **Вариант C**: E2E тесты с реальными PPTX файлами

**Контекст**: Необходимо обеспечить качество и надежность кода.

**✅ РЕШЕНИЕ**: Пирамида A + B + точечно C
- **Обоснование**: Юнит-тесты парсера/маппера — максимальный охват; интеграционные с мок-Figma API — для проверок применения свойств/иерархий
- **E2E**: На небольшой матрице реальных PPTX (smoke-набор), сравнение «золотых» JSON-снимков промежуточной модели

### 14. Тестовые данные
**Вопрос**: Какие тестовые PPTX файлы нужны?
- **Вариант A**: Минимальные файлы для каждого типа элемента
- **Вариант B**: Реальные файлы с комплексными сценариями
- **Вариант C**: Автоматическая генерация тестовых файлов

**Контекст**: Необходимо покрыть все сценарии использования.

**✅ РЕШЕНИЕ**: A + B
- **Обоснование**: Заводим минимальные таргет-кейсы на каждый тип (фон, градиент, списки, стрелки, фигурные стрелки, crop, EXIF, RTL и т.д.) и несколько «боевых» файлов с комплексом эффектов
- **Дополнение**: Автогенерацию (C) можно оставить на потом — она редко покрывает реальные углы

## Вопросы документации

### 15. Документирование API
**Вопрос**: Как документировать внутренние API?
- **Вариант A**: JSDoc комментарии
- **Вариант B**: TypeScript interfaces с описаниями
- **Вариант C**: Отдельная документация в markdown

**Контекст**: Необходимо обеспечить понимание кода командой разработчиков.

**✅ РЕШЕНИЕ**: TypeScript интерфейсы (B) + короткий MD-гайд (C)
- **Обоснование**: TS-контракты — источник правды, а md-страницы («Parser → Mapper → Renderer», форматы сообщений, ImportContext) — для быстрых онбордингов
- **Дополнение**: JSDoc (A) — вторично

### 16. Руководство пользователя
**Вопрос**: Как структурировать документацию для пользователей?
- **Вариант A**: Пошаговое руководство
- **Вариант B**: FAQ с примерами
- **Вариант C**: Интерактивные туториалы

**Контекст**: Пользователи должны понимать возможности и ограничения плагина.

**✅ РЕШЕНИЕ**: Пошаговое руководство (A) + FAQ (B)
- **Обоснование**: Пользователи хотят быстро «как запустить» и «что поддерживается/не поддерживается»
- **Дополнение**: Интерактивные туториалы (C) избыточны

## Приоритизация вопросов

### Критический приоритет
1. Структура проекта и сборка
2. Система сообщений UI ↔ Main
3. Обработка больших файлов
4. Обработка шрифтов

### Высокий приоритет
5. Кэширование и дедупликация
6. Масштабирование и координаты
7. Оптимизация рендеринга
8. Структура тестов

### Средний приоритет
9. Управление состоянием UI
10. Обработка неподдерживаемых элементов
11. Управление памятью
12. Тестовые данные

### Низкий приоритет
13. Версионирование PPTX
14. Совместимость с Figma API
15. Документирование API
16. Руководство пользователя

---

## Дополнительные практические советы

### Парсинг и обработка
- **Парсер**: JSZip + fast-xml-parser (sax-режим), все размеры сразу нормализуем EMU→px
- **Цвета/темы**: Реализуй модуль theme.ts с вычислением tint/shade и кэшем схемных цветов
- **Геометрия фигур**: Конвертер DrawingML a:prstGeom → Figma VECTOR/path; фигурные стрелки хранить параметрами, затем генерация пути

### Списки и текст
- **Списки**: Если Figma API даёт нативные numbered/bulleted, связываем уровни с таб-стопами; если нет — fallback символами (у тебя — нативные доступны)

### Оптимизация
- **Дедуп изображений**: Хэш на Uint8Array и немутирующий ImagePaint (повторное использование ускорит импорт и снизит память)
- **Прогресс**: Подсчитывай общее «весовое» количество задач (слайды + ресурсы), чтобы проценты не «скакали»

### Логирование
- **Логи**: Для каждой деградации (шрифт/эффект) — код причины + человекочитаемое сообщение

---

**Примечание**: Эти вопросы требуют обсуждения с командой и принятия решений на основе технических ограничений и бизнес-требований. Рекомендуется создать отдельные задачи для каждого вопроса и обсудить их в рамках соответствующих этапов разработки.
